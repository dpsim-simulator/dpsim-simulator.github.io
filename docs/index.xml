<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>DPsim – Documentation</title>
    <link>https://dpsim.fein-aachen.org/docs/</link>
    <description>Recent content in Documentation on DPsim</description>
    <generator>Hugo -- gohugo.io</generator>
    
	  <atom:link href="https://dpsim.fein-aachen.org/docs/index.xml" rel="self" type="application/rss+xml" />
    
    
      
        
      
    
    
    <item>
      <title>Docs: Add New Model</title>
      <link>https://dpsim.fein-aachen.org/docs/tasks/add-model/</link>
      <pubDate>Tue, 17 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://dpsim.fein-aachen.org/docs/tasks/add-model/</guid>
      <description>
        
        
        &lt;h2 id=&#34;add-a-component-model&#34;&gt;Add a Component Model&lt;/h2&gt;
&lt;p&gt;In this section we will show the implementation of a new component model by means a three-phase dynamic phasor inductor model.&lt;/p&gt;
&lt;h3 id=&#34;c-oop&#34;&gt;C++ OOP&lt;/h3&gt;
&lt;p&gt;DPsim implements component models in a sub project called CPowerSystems (CPS) that is located in the &lt;em&gt;models&lt;/em&gt; folder.
This folder is added to the DPsim CMake project.
Every component in DPsim is represented by a C++ class.&lt;/p&gt;
&lt;p&gt;DPsim supports different types of solvers (MNA, DAE, NRP).
Each solver requires certain member functions in the component class to be implemented.
These functions are specified by the solver interface classes: &lt;code&gt;MNAInterface.h&lt;/code&gt;, &lt;code&gt;DAEInterface.h&lt;/code&gt;, etc.&lt;/p&gt;
&lt;h3 id=&#34;directory--namespace-structure&#34;&gt;Directory / Namespace Structure&lt;/h3&gt;
&lt;p&gt;For the implementation of the new component, we add two new files&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;models/Source/DP/DP_Ph3_Inductor.cpp&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;models/Include/DP/DP_Ph3_Inductor.h&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In these files, we will implement a new C++ class with the name &lt;code&gt;CPS::DP::Ph3::Inductor&lt;/code&gt;.
The general structure looks as follows.&lt;/p&gt;
&lt;p&gt;Directories:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;DPsim
 |
 |- Source
 |- Include
  \ models
      |- Source
          |- DP
          |- EMT
          |- Static
            \ Signal
      |- Include
          |- DP
          |- EMT
          |- Static
            \ Signal
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Namespaces:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CPS::{DP,EMT,Static,Signal}::{Ph1,Ph3}::{Name}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;attributes&#34;&gt;Attributes&lt;/h3&gt;
&lt;p&gt;Each components has a list of attributes, which has to be specified when creating the components class.&lt;/p&gt;
&lt;p&gt;TODO: explain attribute system&lt;/p&gt;
&lt;h3 id=&#34;tasks-for-prepost-step-functions&#34;&gt;Tasks for Pre/Post-step Functions&lt;/h3&gt;
&lt;p&gt;TODO: add example task dependency graph&lt;/p&gt;
&lt;h3 id=&#34;adding-the-new-component-to-dpsim&#34;&gt;Adding the new Component to DPsim&lt;/h3&gt;
&lt;p&gt;After finishing the implementation of the new component, it needs to be added to the following files:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;models/Include/cps/Components.h&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;models/Source/CMakeLists.txt&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Sources/Python/Module.cpp&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: Examples</title>
      <link>https://dpsim.fein-aachen.org/docs/examples/</link>
      <pubDate>Tue, 17 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://dpsim.fein-aachen.org/docs/examples/</guid>
      <description>
        
        
        &lt;p&gt;The DPsim repository includes &lt;a href=&#34;https://git.rwth-aachen.de/acs/public/simulation/dpsim/dpsim/-/tree/master/Examples&#34;&gt;examples&lt;/a&gt; that can be run locally and on Github you can find a selection of &lt;a href=&#34;https://github.com/DPsim-Simulator/DPsim-Notebooks&#34;&gt;Jupyter notebooks&lt;/a&gt; with results.&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: Tutorials</title>
      <link>https://dpsim.fein-aachen.org/docs/tutorials/</link>
      <pubDate>Tue, 17 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://dpsim.fein-aachen.org/docs/tutorials/</guid>
      <description>
        
        
        &lt;p&gt;On Github you can find a selection of &lt;a href=&#34;https://github.com/DPsim-Simulator/DPsim-Notebooks&#34;&gt;Jupyter notebooks&lt;/a&gt; with results.
These will be updated with more explanations.&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: Reference</title>
      <link>https://dpsim.fein-aachen.org/docs/reference/</link>
      <pubDate>Tue, 17 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://dpsim.fein-aachen.org/docs/reference/</guid>
      <description>
        
        
        &lt;p&gt;The &lt;a href=&#34;https://acs.pages.rwth-aachen.de/public/simulation/dpsim/dpsim/sphinx/about.html&#34;&gt;Sphinx documentation&lt;/a&gt; describes the Python API.&lt;/p&gt;
&lt;p&gt;The &lt;a href=&#34;https://acs.pages.rwth-aachen.de/public/simulation/dpsim/dpsim/doxygen/index.html&#34;&gt;Doxygen documentation&lt;/a&gt; is automatically generated from the C++ code using Doxygen.
It is helpful to understand the general structure of the C++ DPsim core components.&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: Contribution Guidelines</title>
      <link>https://dpsim.fein-aachen.org/docs/contribution-guidelines/</link>
      <pubDate>Tue, 17 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://dpsim.fein-aachen.org/docs/contribution-guidelines/</guid>
      <description>
        
        
        &lt;p&gt;We&amp;rsquo;d love to accept your patches and contributions to this project. 
Please get in touch with us via mail or slack if you would like to contribute.&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: Create New Simulation</title>
      <link>https://dpsim.fein-aachen.org/docs/tasks/create-simulation/</link>
      <pubDate>Wed, 25 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://dpsim.fein-aachen.org/docs/tasks/create-simulation/</guid>
      <description>
        
        
        &lt;p&gt;Here, we will show the implementation of a new simulation scenario defined in C++, which is using DPsim as a library.&lt;/p&gt;
&lt;h2 id=&#34;directory-structure&#34;&gt;Directory Structure&lt;/h2&gt;
&lt;p&gt;In the end, your directory structure should look like as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;my-project
  |- CMakeLists.txt
  |- source
      |- my-scenario.cpp
  |- dpsim (as submodule)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;cmake-file&#34;&gt;CMake File&lt;/h2&gt;
&lt;p&gt;Your CMakeLists could look like this:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cmake_minimum_required(VERSION 3.5)
project(my-project CXX)

add_subdirectory(dpsim)

add_executable(my-scenario source/my-scenario.cpp)
  target_link_libraries(my-scenario dpsim)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;build-the-project&#34;&gt;Build the Project&lt;/h2&gt;
&lt;p&gt;The build process is similar to the one of DPsim:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cd my-project
$ mkdir build &amp;amp;&amp;amp; cd build
$ cmake ..
$ make my-scenario&lt;/code&gt;&lt;/pre&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: Basic Elements</title>
      <link>https://dpsim.fein-aachen.org/docs/models/basic-elements/</link>
      <pubDate>Wed, 18 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://dpsim.fein-aachen.org/docs/models/basic-elements/</guid>
      <description>
        
        
        

      </description>
    </item>
    
    <item>
      <title>Docs: Branches</title>
      <link>https://dpsim.fein-aachen.org/docs/models/branches/</link>
      <pubDate>Wed, 18 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://dpsim.fein-aachen.org/docs/models/branches/</guid>
      <description>
        
        
        &lt;script src=&#34;https://polyfill.io/v3/polyfill.min.js?features=es6&#34;&gt;&lt;/script&gt;
&lt;script id=&#34;MathJax-script&#34; async src=&#34;https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js&#34;&gt;&lt;/script&gt;
&lt;h2 id=&#34;rx-line&#34;&gt;RX-Line&lt;/h2&gt;
&lt;h2 id=&#34;pi-line&#34;&gt;PI-Line&lt;/h2&gt;
&lt;h2 id=&#34;transformer&#34;&gt;Transformer&lt;/h2&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: Dynamic Phasors</title>
      <link>https://dpsim.fein-aachen.org/docs/concepts/dyn-phasors/</link>
      <pubDate>Wed, 18 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://dpsim.fein-aachen.org/docs/concepts/dyn-phasors/</guid>
      <description>
        
        
        &lt;p&gt;In the power systems community, dynamic phasors were initially introduced for power electronics analysis &lt;a href=&#34;https://ieeexplore.ieee.org/document/76811&#34;&gt;Sanders1991&lt;/a&gt; as a more general approach than state-space averaging.
They were used to construct efficient models for the dynamics of switching gate phenomena with a high level of detail as shown in &lt;a href=&#34;https://ieeexplore.ieee.org/abstract/document/744524&#34;&gt;Mattavelli1999&lt;/a&gt;.
A few years later, dynamic phasors were also employed for power system simulation as described in &lt;a href=&#34;https://www.research-collection.ethz.ch/handle/20.500.11850/123490&#34;&gt;Demiray2008&lt;/a&gt;.
In &lt;a href=&#34;https://ieeexplore.ieee.org/document/4026700&#34;&gt;Strunz2006&lt;/a&gt; the authors combine the dynamic phasor approach with the Electromagnetic Transients Program (EMTP) simulator concept which includes Modified Nodal Analysis (MNA).
Further research topics include fault and stability analysis under unbalanced conditions as presented in &lt;a href=&#34;https://ieeexplore.ieee.org/document/871734&#34;&gt;Stankovic2000&lt;/a&gt; and also rotating machine models have been developed in dynamic phasors &lt;a href=&#34;https://ieeexplore.ieee.org/document/4282063&#34;&gt;Zhang 2007&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;bandpass-signals-and-baseband-representation&#34;&gt;Bandpass Signals and Baseband Representation&lt;/h2&gt;
&lt;p&gt;Although here, dynamic phasors are presented as a power system modelling tool, it should be noted that the concept is also known in other domains, for example, microwave and communications engineering [Maas2003, Suarez2009, Haykin2009, Proakis2001].
In these domains, the approach is often denoted as base band representation or complex envelope.
Another common term coming from power electrical engineering is shifted frequency analysis (SFA).
In the following, the general approach of dynamic phasors for power system simulation is explained starting from the idea of bandpass signals.
This is because the 50 Hz or 60 Hz fundamental and small deviations from it can be seen as such a bandpass signal.
Futhermore, higher frequencies, for example, generated by power electronics can be modelled in a similar way.&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: Induction Machine</title>
      <link>https://dpsim.fein-aachen.org/docs/models/induction-machine/</link>
      <pubDate>Wed, 18 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://dpsim.fein-aachen.org/docs/models/induction-machine/</guid>
      <description>
        
        
        

      </description>
    </item>
    
    <item>
      <title>Docs: Nodal Analysis</title>
      <link>https://dpsim.fein-aachen.org/docs/concepts/nodal-analysis/</link>
      <pubDate>Wed, 18 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://dpsim.fein-aachen.org/docs/concepts/nodal-analysis/</guid>
      <description>
        
        
        &lt;script src=&#34;https://polyfill.io/v3/polyfill.min.js?features=es6&#34;&gt;&lt;/script&gt;
&lt;script id=&#34;MathJax-script&#34; async src=&#34;https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js&#34;&gt;&lt;/script&gt;
&lt;p&gt;A circuit with &lt;span class=&#34;math inline&#34;&gt;\(b\)&lt;/span&gt; branches has &lt;span class=&#34;math inline&#34;&gt;\(2b\)&lt;/span&gt; unknowns since there are &lt;span class=&#34;math inline&#34;&gt;\(b\)&lt;/span&gt; voltages and &lt;span class=&#34;math inline&#34;&gt;\(b\)&lt;/span&gt; currents. Hence, &lt;span class=&#34;math inline&#34;&gt;\(2b\)&lt;/span&gt; linear independent equations are required to solve the circuit. If the circuit has &lt;span class=&#34;math inline&#34;&gt;\(n\)&lt;/span&gt; nodes and &lt;span class=&#34;math inline&#34;&gt;\(b\)&lt;/span&gt; branches, it has&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Kirchoff’s current law (KCL) equations&lt;/li&gt;
&lt;li&gt;Kirchoff’s voltage law (KVL) equations&lt;/li&gt;
&lt;li&gt;Characteristic equations (Ohm’s Law)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;There are only &lt;span class=&#34;math inline&#34;&gt;\(n-1\)&lt;/span&gt; KCLs since the nth equation is a linear combination of the remaining &lt;span class=&#34;math inline&#34;&gt;\(n-1\)&lt;/span&gt;. At the same time, it can be demonstrated that if we can imagine a very high number of closed paths in the network, only &lt;span class=&#34;math inline&#34;&gt;\(b-n+1\)&lt;/span&gt; are able to provide independent KVLs. Finally there are &lt;span class=&#34;math inline&#34;&gt;\(b\)&lt;/span&gt; characteristic equations, describing the behavior of the branch, making a total of &lt;span class=&#34;math inline&#34;&gt;\(2b\)&lt;/span&gt; linear independent equations.&lt;/p&gt;
&lt;p&gt;The nodal analysis method reduces the number of equations that need to be solved simultaneously. &lt;span class=&#34;math inline&#34;&gt;\(n-1\)&lt;/span&gt; voltage variables are defined and solved, writing &lt;span class=&#34;math inline&#34;&gt;\(n-1\)&lt;/span&gt; KCL based equations. A circuit can be solved using Nodal Analysis as follows&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Select a reference node (mathematical ground) and number the remaining &lt;span class=&#34;math inline&#34;&gt;\(n-1\)&lt;/span&gt; nodes, that are the independent voltage variables&lt;/li&gt;
&lt;li&gt;Represent every branch current &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; as a function of node voltage variables &lt;span class=&#34;math inline&#34;&gt;\(v\)&lt;/span&gt; with the general expression &lt;span class=&#34;math inline&#34;&gt;\(i = g(v)\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;Write &lt;span class=&#34;math inline&#34;&gt;\(n-1\)&lt;/span&gt; KCL based equations in terms of node voltage variable.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The resulting equations can be written in matrix form and have to be solved for &lt;span class=&#34;math inline&#34;&gt;\(v\)&lt;/span&gt;. &lt;span class=&#34;math display&#34;&gt;\[\boldsymbol{Y} \boldsymbol{v} = \boldsymbol{i}\]&lt;/span&gt;&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: Powerflow</title>
      <link>https://dpsim.fein-aachen.org/docs/concepts/powerflow/</link>
      <pubDate>Wed, 18 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://dpsim.fein-aachen.org/docs/concepts/powerflow/</guid>
      <description>
        
        
        &lt;script&gt;
MathJax = {
  tex: {
    tags: &#39;all&#39;
  }
};
&lt;/script&gt;
&lt;script src=&#34;https://polyfill.io/v3/polyfill.min.js?features=es6&#34;&gt;&lt;/script&gt;
&lt;script id=&#34;MathJax-script&#34; async src=&#34;https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js&#34;&gt;&lt;/script&gt;
&lt;p&gt;The power flow problem is about the calculation of voltage magnitudes and angles for one set of buses. The solution is obtained from a given set of voltage magnitudes and power levels for a specific model of the network configuration. The power flow solution exhibits the voltages and angles at all buses and real and reactive flows can be deduced from the same.&lt;/p&gt;
&lt;h2 id=&#34;power-system-model&#34;&gt;Power System Model&lt;/h2&gt;
&lt;p&gt;Power systems are modeled as a network of buses (nodes) and branches (lines). To a network bus, components such a generator, load, and transmission substation can be connected. Each bus in the network is fully described by the following four electrical quantities:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span class=&#34;math inline&#34;&gt;\(\vert V_{k} \vert\)&lt;/span&gt;: the voltage magnitude&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;math inline&#34;&gt;\(\theta_{k}\)&lt;/span&gt;: the voltage phase angle&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;math inline&#34;&gt;\(P_{k}\)&lt;/span&gt;: the active power&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;math inline&#34;&gt;\(Q_{k}\)&lt;/span&gt;: the reactive power&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;There are three types of networks buses: VD bus, PV bus and PQ bus. Depending on the type of the bus, two of the four electrical quantities are specified as shown in the table below.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr class=&#34;header&#34;&gt;
&lt;th&gt;Bus Type&lt;/th&gt;
&lt;th&gt;Known&lt;/th&gt;
&lt;th&gt;Unknown&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td&gt;&lt;span class=&#34;math inline&#34;&gt;\(VD\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&#34;math inline&#34;&gt;\(\vert V_{k} \vert, \theta_{k}\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&#34;math inline&#34;&gt;\(P_{k}, Q_{k}\)&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td&gt;&lt;span class=&#34;math inline&#34;&gt;\(PV\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&#34;math inline&#34;&gt;\(P_{k}, \vert V_{k} \vert\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&#34;math inline&#34;&gt;\(Q_{k}, \theta_{k}\)&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td&gt;&lt;span class=&#34;math inline&#34;&gt;\(PQ\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&#34;math inline&#34;&gt;\(P_{k}, Q_{k}\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&#34;math inline&#34;&gt;\(\vert V_{k} \vert, \theta_{k}\)&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;single-phase-power-flow-problem&#34;&gt;Single Phase Power Flow Problem&lt;/h2&gt;
&lt;p&gt;The power flow problem can be expressed by the goal to bring a mismatch function &lt;span class=&#34;math inline&#34;&gt;\(\vec{f}\)&lt;/span&gt; to zero. The value of the mismatch function depends on a solution vector &lt;span class=&#34;math inline&#34;&gt;\(\vec{x}\)&lt;/span&gt;: &lt;span class=&#34;math display&#34;&gt;\[ \vec{f}(\vec{x}) = 0 \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;As &lt;span class=&#34;math inline&#34;&gt;\(\vec{f}(\vec{x})\)&lt;/span&gt; will be nonlinear, the equation system will be solved with Newton-Raphson:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[-\textbf{J}(\vec{x}) \Delta \vec{x} = \vec{f} (\vec{x})\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;where &lt;span class=&#34;math inline&#34;&gt;\(\Delta \vec{x}\)&lt;/span&gt; is the correction of the solution vector and &lt;span class=&#34;math inline&#34;&gt;\(\textbf{J}(\vec{x})\)&lt;/span&gt; is the Jacobian matrix. The solution vector &lt;span class=&#34;math inline&#34;&gt;\(\vec{x}\)&lt;/span&gt; represents the voltage &lt;span class=&#34;math inline&#34;&gt;\(\vec{V}\)&lt;/span&gt; by polar or cartesian quantities. The mismatch function &lt;span class=&#34;math inline&#34;&gt;\(\vec{f}\)&lt;/span&gt; will either represent the power mismatch &lt;span class=&#34;math inline&#34;&gt;\(\Delta \vec{S}\)&lt;/span&gt; in terms of&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[\left [ \begin{array}{c} \Delta \vec{P} \\ \Delta \vec{Q} \end{array} \right ]\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;or the current mismatch &lt;span class=&#34;math inline&#34;&gt;\(\Delta \vec{I}\)&lt;/span&gt; in terms of&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[\left [ \begin{array}{c} \Delta \vec{I_{real}} \\ \Delta \vec{I_{imag}} \end{array} \right ]\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;where the vectors split the complex quantities into real and imaginary parts. Futhermore, the solution vector &lt;span class=&#34;math inline&#34;&gt;\(\vec{x}\)&lt;/span&gt; will represent &lt;span class=&#34;math inline&#34;&gt;\(\vec{V}\)&lt;/span&gt; either by polar coordinates&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[\left [ \begin{array}{c} \vec{\delta} \\ \vert \vec{V} \vert \end{array} \right ]\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;or rectangular coordinates&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[\left [ \begin{array}{c} \vec{V_{real}} \\ \vec{V_{imag}} \end{array} \right ]\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;This results in four different formulations of the powerflow problem:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;with power mismatch function and polar coordinates&lt;/li&gt;
&lt;li&gt;with power mismatch function and rectangular coordinates&lt;/li&gt;
&lt;li&gt;with current mismatch function and polar coordinates&lt;/li&gt;
&lt;li&gt;with current mismatch function and rectangular coordinates&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;To solve the problem using NR, we need to formulate &lt;span class=&#34;math inline&#34;&gt;\(\textbf{J} (\vec{x})\)&lt;/span&gt; and &lt;span class=&#34;math inline&#34;&gt;\(\vec{f} (\vec{x})\)&lt;/span&gt; for each powerflow problem formulation.&lt;/p&gt;
&lt;h3 id=&#34;powerflow-problem-with-power-mismatch-function-and-polar-coordinates&#34;&gt;Powerflow Problem with Power Mismatch Function and Polar Coordinates&lt;/h3&gt;
&lt;h4 id=&#34;formulation-of-mismatch-function&#34;&gt;Formulation of Mismatch Function&lt;/h4&gt;
&lt;p&gt;The injected power at a node &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; is given by: &lt;span class=&#34;math display&#34;&gt;\[S_{k} = V_{k} I _{k}^{*}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;The current injection into any bus &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; may be expressed as: &lt;span class=&#34;math display&#34;&gt;\[I_{k} = \sum_{j=1}^{N} Y_{kj} V_{j}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Substitution yields: &lt;span class=&#34;math display&#34;&gt;\[\begin{align}
  S_{k} =&amp;amp; V_{k} \left ( \sum_{j=1}^{N} Y_{kj} V_{j} \right )^{*}
        =&amp;amp; V_{k} \sum_{j=1}^{N} Y_{kj}^{*} V_{j} ^{*}
\end{align}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;We may define &lt;span class=&#34;math inline&#34;&gt;\(G_{kj}\)&lt;/span&gt; and &lt;span class=&#34;math inline&#34;&gt;\(B_{kj}\)&lt;/span&gt; as the real and imaginary parts of the admittance matrix element &lt;span class=&#34;math inline&#34;&gt;\(Y_{kj}\)&lt;/span&gt; respectively, so that &lt;span class=&#34;math inline&#34;&gt;\(Y_{kj} = G_{kj} + jB_{kj}\)&lt;/span&gt;. Then we may rewrite the last equation: &lt;span class=&#34;math display&#34;&gt;\[\begin{align}
  S_{k} &amp;amp;= V_{k} \sum_{j=1}^{N} Y_{kj}^{*} V_{j}^{*} \nonumber \\
            &amp;amp;= \vert V_{k} \vert \angle \theta_{k} \sum_{j=1}^{N} (G_{kj} + jB_{kj})^{*} ( \vert V_{j} \vert \angle \theta_{j})^{*} \nonumber \\
            &amp;amp;= \vert V_{k} \vert \angle \theta_{k} \sum_{j=1}^{N} (G_{kj} - jB_{kj}) ( \vert V_{j} \vert \angle - \theta_{j}) \nonumber \\
            &amp;amp;= \sum_{j=1} ^{N} \vert V_{k} \vert \angle \theta_{k} ( \vert V_{j} \vert \angle - \theta_{j}) (G_{kj} - jB_{kj}) \nonumber \\
            &amp;amp;= \sum_{j=1} ^{N} \left ( \vert V_{k} \vert \vert V_{j} \vert \angle (\theta_{k} - \theta_{j}) \right ) (G_{kj} - jB_{kj}) \nonumber \\
            &amp;amp;= \sum_{j=1} ^{N} \vert V_{k} \vert \vert V_{j} \vert \left ( cos(\theta_{k} - \theta_{j}) + jsin(\theta_{k} - \theta_{j}) \right ) (G_{kj} - jB_{kj})
    \label{eq:compl_power}
\end{align}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;If we now perform the algebraic multiplication of the two terms inside the parentheses, and collect real and imaginary parts, and recall that &lt;span class=&#34;math inline&#34;&gt;\(S_{k} = P_{k} + jQ_{k}\)&lt;/span&gt;, we can express &lt;span class=&#34;math inline&#34;&gt;\(\eqref{eq:compl_power}\)&lt;/span&gt; as two equations: one for the real part, &lt;span class=&#34;math inline&#34;&gt;\(P_{k}\)&lt;/span&gt;, and one for the imaginary part, &lt;span class=&#34;math inline&#34;&gt;\(Q_{k}\)&lt;/span&gt;, according to:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[\begin{align}
    {P}_{k} = \sum_{j=1}^{N} \vert V_{k} \vert \vert V_{j} \vert \left ( G_{kj}cos(\theta_{k} - \theta_{j}) + B_{kj} sin(\theta_{k} - \theta_{j}) \right ) \label{eq:active_power}\\
    {Q}_{k} = \sum_{j=1}^{N} \vert V_{k} \vert \vert V_{j} \vert \left ( G_{kj}sin(\theta_{k} - \theta_{j}) - B_{kj} cos(\theta_{k} - \theta_{j}) \right ) \label{eq:reactive_power}
\end{align}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;These equations are called the power flow equations, and they form the fundamental building block from which we solve the power flow problem.&lt;/p&gt;
&lt;p&gt;We consider a power system network having &lt;span class=&#34;math inline&#34;&gt;\(N\)&lt;/span&gt; buses. We assume one VD bus, &lt;span class=&#34;math inline&#34;&gt;\(N_{PV}-1\)&lt;/span&gt; PV buses and &lt;span class=&#34;math inline&#34;&gt;\(N-N_{PV}\)&lt;/span&gt; PQ buses. We assume that the VD bus is numbered bus &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt;, the PV buses are numbered &lt;span class=&#34;math inline&#34;&gt;\(2,...,N_{PV}\)&lt;/span&gt;, and the PQ buses are numbered &lt;span class=&#34;math inline&#34;&gt;\(N_{PV}+1,...,N\)&lt;/span&gt;. We define the vector of unknown as the composite vector of unknown angles &lt;span class=&#34;math inline&#34;&gt;\(\vec{\theta}\)&lt;/span&gt; and voltage magnitudes &lt;span class=&#34;math inline&#34;&gt;\(\vert \vec{V} \vert\)&lt;/span&gt;: &lt;span class=&#34;math display&#34;&gt;\[\begin{align}
    \vec{x} = \left[ \begin{array}{c} \vec{\theta} \\ \vert \vec{V} \vert \\ \end{array} \right ]
                    = \left[ \begin{array}{c} \theta_{2} \\ \theta_{3} \\ \vdots \\ \theta_{N} \\ \vert V_{N_{PV+1}} \vert \\ \vert V_{N_{PV+2}} \vert \\ \vdots \\ \vert V_{N} \vert \end{array} \right]
\end{align}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;The right-hand sides of equations &lt;span class=&#34;math inline&#34;&gt;\(\eqref{eq:active_power}\)&lt;/span&gt; and &lt;span class=&#34;math inline&#34;&gt;\(\eqref{eq:reactive_power}\)&lt;/span&gt; depend on the elements of the unknown vector &lt;span class=&#34;math inline&#34;&gt;\(\vec{x}\)&lt;/span&gt;. Expressing this dependency more explicitly, we rewrite these equations as: &lt;span class=&#34;math display&#34;&gt;\[\begin{align}
    P_{k} = P_{k} (\vec{x}) \Rightarrow P_{k}(\vec{x}) - P_{k} &amp;amp;= 0 \quad \quad k = 2,...,N \\
    Q_{k} = Q_{k} (\vec{x}) \Rightarrow Q_{k} (\vec{x}) - Q_{k} &amp;amp;= 0 \quad \quad k = N_{PV}+1,...,N
\end{align}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;We now define the mismatch vector &lt;span class=&#34;math inline&#34;&gt;\(\vec{f} (\vec{x})\)&lt;/span&gt; as: &lt;span class=&#34;math display&#34;&gt;\[\begin{align*}
\vec{f} (\vec{x}) = \left [ \begin{array}{c} f_{1}(\vec{x}) \\ \vdots \\ f_{N-1}(\vec{x}) \\ ------ \\ f_{N}(\vec{x}) \\ \vdots \\ f_{2N-N_{PV} -1}(\vec{x}) \end{array} \right ]
    = \left [ \begin{array}{c} P_{2}(\vec{x}) - P_{2} \\ \vdots \\ P_{N}(\vec{x}) - P_{N} \\ --------- \\ Q_{N_{PV}+1}(\vec{x}) - Q_{N_{PV}+1} \\ \vdots \\ Q_{N}(\vec{x}) - Q_{N} \end{array} \right]
    = \left [ \begin{array}{c} \Delta P_{2} \\ \vdots \\ \Delta P_{N} \\ ------ \\ \Delta Q_{N_{PV}+1} \\ \vdots \\ \Delta Q_{N} \end{array} \right ]
    = \vec{0}
\end{align*}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;That is a system of nonlinear equations. This nonlinearity comes from the fact that &lt;span class=&#34;math inline&#34;&gt;\(P_{k}\)&lt;/span&gt; and &lt;span class=&#34;math inline&#34;&gt;\(Q_{k}\)&lt;/span&gt; have terms containing products of some of the unknowns and also terms containing trigonometric functions of some the unknowns.&lt;/p&gt;
&lt;h4 id=&#34;formulation-of-jacobian&#34;&gt;Formulation of Jacobian&lt;/h4&gt;
&lt;p&gt;As discussed in the previous section, the power flow problem will be solved using the Newton-Raphson method. Here, the Jacobian matrix is obtained by taking all first-order partial derivates of the power mismatch functions with respect to the voltage angles &lt;span class=&#34;math inline&#34;&gt;\(\theta_{k}\)&lt;/span&gt; and magnitudes &lt;span class=&#34;math inline&#34;&gt;\(\vert V_{k} \vert\)&lt;/span&gt; as: &lt;span class=&#34;math display&#34;&gt;\[\begin{align}
    J_{jk}^{P \theta} &amp;amp;= \frac{\partial P_{j} (\vec{x} ) } {\partial \theta_{k}} = \vert V_{j} \vert \vert V_{k} \vert \left ( G_{jk} sin(\theta_{j} - \theta_{k}) -                                                                B_{jk} cos(\theta_{j} - \theta_{k} ) \right ) \\
    J_{jj}^{P \theta} &amp;amp;= \frac{\partial P_{j}(\vec{x})}{\partial \theta_{j}} = -Q_{j} (\vec{x} ) - B_{jj} \vert V_{j} \vert ^{2} \\
    J_{jk}^{Q \theta} &amp;amp;= \frac{\partial Q_{j}(\vec{x})}{\partial \theta_{k}} = - \vert V_{j} \vert \vert V_{k} \vert \left ( G_{jk} cos(\theta_{j} - \theta_{k}) +                                                              B_{jk} sin(\theta_{j} - \theta_{k}) \right ) \\
     J_{jj}^{Q \theta} &amp;amp;= \frac{\partial Q_{j}(\vec{x})}{\partial \theta_{k}} = P_{j} (\vec{x} ) - G_{jj} \vert V_{j} \vert ^{2} \\
     J_{jk}^{PV} &amp;amp;= \frac{\partial P_{j} (\vec{x} ) } {\partial \vert V_{k} \vert } = \vert V_{j} \vert \left ( G_{jk} cos(\theta_{j} - \theta_{k}) +                                                               B_{jk} sin(\theta_{j} - \theta_{k}) \right ) \\
     J_{jj}^{PV} &amp;amp;= \frac{\partial P_{j}(\vec{x})}{\partial \vert V_{j} \vert } = \frac{P_{j} (\vec{x} )}{\vert V_{j} \vert} + G_{jj} \vert V_{j} \vert \\
     J_{jk}^{QV} &amp;amp;= \frac{\partial Q_{j} (\vec{x} ) } {\partial \vert V_{k} \vert } = \vert V_{j} \vert \left ( G_{jk} sin(\theta_{j} - \theta_{k}) +                                                               B_{jk} cos(\theta_{j} - \theta_{k}) \right ) \\
     J_{jj}^{QV} &amp;amp;= \frac{\partial Q_{j}(\vec{x})}{\partial \vert V_{j} \vert } = \frac{Q_{j} (\vec{x} )}{\vert V_{j} \vert} - B_{jj} \vert V_{j} \vert \\
\end{align}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;The linear system of equations that is solved in every Newton iteration can be written in matrix form as follows: &lt;span class=&#34;math display&#34;&gt;\[\begin{align}
    -\left [ \begin{array}{cccccc} \frac{\partial \Delta P_{2} }{\partial \theta_{2}} &amp;amp; \cdots &amp;amp; \frac{\partial \Delta P_{2} }{\partial \theta_{N}} &amp;amp;
            \frac{\partial \Delta P_{2} }{\partial \vert V_{N_{G+1}} \vert} &amp;amp; \cdots &amp;amp; \frac{\partial \Delta P_{2} }{\partial \vert V_{N} \vert}    \\
            \vdots &amp;amp; \ddots &amp;amp; \vdots &amp;amp; \vdots &amp;amp; \ddots &amp;amp; \vdots \\
             \frac{\partial \Delta P_{N} }{\partial \theta_{2}} &amp;amp; \cdots &amp;amp; \frac{\partial \Delta P_{N}}{\partial \theta_{N}} &amp;amp;
            \frac{\partial \Delta P_{N}}{\partial \vert V_{N_{G+1}} \vert } &amp;amp; \cdots &amp;amp; \frac{\partial \Delta P_{N}}{\partial \vert V_{N} \vert} \\
             \frac{\partial \Delta Q_{N_{G+1}} }{\partial \theta_{2}} &amp;amp; \cdots &amp;amp; \frac{\partial \Delta Q_{N_{G+1}} }{\partial \theta_{N}} &amp;amp;
            \frac{\partial \Delta Q_{N_{G+1}} }{\partial \vert V_{N_{G+1}} \vert } &amp;amp; \cdots &amp;amp; \frac{\partial \Delta Q_{N_{G+1}} }{\partial \vert V_{N} \vert}   \\
            \vdots &amp;amp; \ddots &amp;amp; \vdots &amp;amp; \vdots &amp;amp; \ddots &amp;amp; \vdots \\
             \frac{\partial \Delta Q_{N}}{\partial \theta_{2}} &amp;amp; \cdots &amp;amp; \frac{\partial \Delta Q_{N}}{\partial \theta_{N}} &amp;amp;
            \frac{\partial \Delta Q_{N}}{\partial \vert V_{N_{G+1}} \vert } &amp;amp; \cdots &amp;amp; \frac{\partial \Delta Q_{N}}{\partial \vert V_{N} \vert}
            \end{array} \right ]
    \left [ \begin{array}{c} \Delta \theta_{2} \\ \vdots \\ \Delta \theta_{N} \\ \Delta \vert V_{N_{G+1}} \vert \\ \vdots \\ \Delta \vert V_{N} \vert \end{array} \right ]
    = \left [ \begin{array}{c} \Delta P_{2} \\ \vdots \\ \Delta P_{N} \\ \Delta Q_{N_{G+1}} \\ \vdots \\ \Delta Q_{N} \end{array} \right ]
\end{align}\]&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&#34;solution-of-the-problem&#34;&gt;Solution of the Problem&lt;/h2&gt;
&lt;p&gt;The solution update formula is given by: &lt;span class=&#34;math display&#34;&gt;\[\begin{align}
    \vec{x}^{(i+1)} = \vec{x}^{(i)} + \Delta \vec{x}^{(i)} = \vec{x}^{(i)} - \textbf{J}^{-1} \vec{f} (\vec{x}^{(i)})
\end{align}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;To sum up, the NR algorithm, for application to the power flow problem is:&lt;/p&gt;
&lt;ol type=&#34;1&#34;&gt;
&lt;li&gt;Set the iteration counter to &lt;span class=&#34;math inline&#34;&gt;\(i=1\)&lt;/span&gt;. Use the initial solution &lt;span class=&#34;math inline&#34;&gt;\(V_{i} = 1 \angle 0^{\circ}\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;Compute the mismatch vector &lt;span class=&#34;math inline&#34;&gt;\(\vec{f}({\vec{x}})\)&lt;/span&gt; using the power flow equations&lt;/li&gt;
&lt;li&gt;Perform the following stopping criterion tests:
&lt;ul&gt;
&lt;li&gt;If &lt;span class=&#34;math inline&#34;&gt;\(\vert \Delta P_{i} \vert &amp;lt; \epsilon_{P}\)&lt;/span&gt; for all type PQ and PV buses and&lt;/li&gt;
&lt;li&gt;If &lt;span class=&#34;math inline&#34;&gt;\(\vert \Delta Q_{i} \vert &amp;lt; \epsilon_{Q}\)&lt;/span&gt; for all type PQ&lt;/li&gt;
&lt;li&gt;Then go to step 6&lt;/li&gt;
&lt;li&gt;Otherwise, go to step 4.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Evaluate the Jacobian matrix &lt;span class=&#34;math inline&#34;&gt;\(\textbf{J}^{(i)}\)&lt;/span&gt; and compute &lt;span class=&#34;math inline&#34;&gt;\(\Delta \vec{x}^{(i)}\)&lt;/span&gt;.&lt;/li&gt;
&lt;li&gt;Compute the update solution vector &lt;span class=&#34;math inline&#34;&gt;\(\vec{x}^{(i+1)}\)&lt;/span&gt;. Return to step 3.&lt;/li&gt;
&lt;li&gt;Stop.&lt;/li&gt;
&lt;/ol&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: Synchronous Generator</title>
      <link>https://dpsim.fein-aachen.org/docs/models/synchronous-generator/</link>
      <pubDate>Wed, 18 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://dpsim.fein-aachen.org/docs/models/synchronous-generator/</guid>
      <description>
        
        
        &lt;script src=&#34;https://polyfill.io/v3/polyfill.min.js?features=es6&#34;&gt;&lt;/script&gt;
&lt;script id=&#34;MathJax-script&#34; async src=&#34;https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js&#34;&gt;&lt;/script&gt;
&lt;h2 id=&#34;basic-equations&#34;&gt;Basic Equations&lt;/h2&gt;
&lt;p&gt;The equations of the stator and rotor voltages are&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[\begin{align}
    \mathbf{v}_{abcs} &amp;amp;= \mathbf{R}_s \mathbf{i}_{abcs} + \frac{d}{dt} \boldsymbol{\lambda}_{abcs} \\
    \mathbf{v}_{dqr} &amp;amp;= \mathbf{R}_r \mathbf{i}_{dqr} + \frac{d}{dt} \boldsymbol{\lambda}_{dqr}
\end{align}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;where&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[\begin{align}
  \mathbf{v}_{abcs} &amp;amp;=
  \begin{pmatrix}
    v_{as} &amp;amp; v_{bs} &amp;amp; v_{cs}
  \end{pmatrix}^T \\
  %
  \mathbf{v}_{dqr} &amp;amp;=
  \begin{pmatrix}
    v_{fd} &amp;amp; v_{kd} &amp;amp; v_{kq1} &amp;amp; v_{kq2}
  \end{pmatrix}^T \\
  %
  \mathbf{i}_{abcs} &amp;amp;=
  \begin{pmatrix}
    i_{as} &amp;amp; i_{bs} &amp;amp; i_{cs}
  \end{pmatrix}^T \\
  %
  \mathbf{i}_{dqr} &amp;amp;=
  \begin{pmatrix}
    i_{fd} &amp;amp; i_{kd} &amp;amp; i_{kq1} &amp;amp; i_{kq2}
  \end{pmatrix}^T \\
  %
  \boldsymbol{\lambda}_{abcs} &amp;amp;=
  \begin{pmatrix}
    \lambda_{as} &amp;amp; \lambda_{bs} &amp;amp; \lambda_{cs}
  \end{pmatrix}^T \\
  %
  \boldsymbol{\lambda}_{dqr} &amp;amp;=
  \begin{pmatrix}
    \lambda_{fd} &amp;amp; \lambda_{kd} &amp;amp; \lambda_{kq1} &amp;amp; \lambda_{kq2}
  \end{pmatrix}^T \\
  %
  \mathbf{R}_s &amp;amp;= diag
  \begin{bmatrix}
    R_s &amp;amp; R_s &amp;amp; R_s
  \end{bmatrix} \\
  %
  \mathbf{R}_r &amp;amp;= diag
  \begin{bmatrix}
    R_{fd} &amp;amp; R_{kd} &amp;amp; R_{kq1} &amp;amp; R_{kq2}
  \end{bmatrix}
\end{align}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;The flux linkage equations are defined as&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[\begin{equation}
    \begin{bmatrix}
        \boldsymbol{\lambda}_{abcs} \\
        \boldsymbol{\lambda}_{dqr}
    \end{bmatrix}
    =
    \begin{bmatrix}
        \mathbf{L}_s &amp;amp; \mathbf{L}_{rs} \\
        {(\mathbf{L}_{rs})}^{T} &amp;amp; \mathbf{L}_r
    \end{bmatrix}
    \begin{bmatrix}
        \mathbf{i}_{abcs} \\
        \mathbf{i}_{dqr}
  \end{bmatrix}
\end{equation}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;The inductance matrices are varying with the rotor position &lt;span class=&#34;math inline&#34;&gt;\(\theta_r\)&lt;/span&gt; which varies with time.&lt;/p&gt;
&lt;p&gt;The mechanical equations are:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[\begin{align}
  \frac{d\theta_r}{dt} &amp;amp;= \omega_r \\
  \frac{d\omega_r}{dt} &amp;amp;= \frac{P}{2J} (T_e-T_m)
\end{align}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;where &lt;span class=&#34;math inline&#34;&gt;\(\theta_r\)&lt;/span&gt; is the rotor position, &lt;span class=&#34;math inline&#34;&gt;\(\omega_r\)&lt;/span&gt; is the angular electrical speed, &lt;span class=&#34;math inline&#34;&gt;\(P\)&lt;/span&gt; is the number of poles, &lt;span class=&#34;math inline&#34;&gt;\(J\)&lt;/span&gt; is the moment of inertia, &lt;span class=&#34;math inline&#34;&gt;\(T_m\)&lt;/span&gt; and &lt;span class=&#34;math inline&#34;&gt;\(T_e\)&lt;/span&gt; are the mechanical and electrical torque, respectively. Motor convention is used for all models.&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: VS-Inverter</title>
      <link>https://dpsim.fein-aachen.org/docs/models/power-electronics/</link>
      <pubDate>Wed, 18 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://dpsim.fein-aachen.org/docs/models/power-electronics/</guid>
      <description>
        
        
        

      </description>
    </item>
    
    <item>
      <title>Docs: Build</title>
      <link>https://dpsim.fein-aachen.org/docs/getting-started/build/</link>
      <pubDate>Thu, 05 Jan 2017 00:00:00 +0000</pubDate>
      
      <guid>https://dpsim.fein-aachen.org/docs/getting-started/build/</guid>
      <description>
        
        
        &lt;h2 id=&#34;docker-based&#34;&gt;Docker based&lt;/h2&gt;
&lt;p&gt;Clone the repository&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git clone --recurse-submodules git@git.rwth-aachen.de:acs/public/simulation/dpsim/dpsim.git
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;or using https if you do not have an account&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git clone --recurse-submodules https://git.rwth-aachen.de:acs/public/simulation/dpsim/dpsim
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In the repository, there is a Docker file with all required dependencies&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cd dpsim
$ docker build -t rwthacs/dpsim-dev -f Packaging/Docker/Dockerfile.dev .
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Alternatively, the image can be pulled from DockerHub like so&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ docker pull rwthacs/dpsim-dev
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;For OS specific instructions on how to install requirements, see the sections below.&lt;/p&gt;
&lt;p&gt;Next, run a Docker container&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cd dpsim
$ docker run -it -p 8888:8888 -v $(pwd):/dpsim --privileged rwthacs/dpsim-dev bash
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The option &lt;code&gt;-p&lt;/code&gt; maps the port 8888 of the container to the docker host. This is required to access the jupyter lab instance inside the container. The option &lt;code&gt;--privileged&lt;/code&gt; is required for debug builds.&lt;/p&gt;
&lt;p&gt;For Windows, you might need to specify the current directory with curly brackets&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ docker run -it -p 8888:8888 -v ${pwd}:/dpsim --privileged rwthacs/dpsim-dev bash
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now, you should be in an interactive session inside the docker container.&lt;/p&gt;
&lt;p&gt;The DPsim C++ and Python library without C++ examples or documentation can be built as follows&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cd /dpsim
$ mkdir build &amp;amp;&amp;amp; cd build
$ cmake ..
$ cmake --build . --target dpsim_python
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To build everything run&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cmake --build .
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you would like to use the Python package, it has to be added to the path&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cd /dpsim/build
$ export PYTHONPATH=$(pwd)/Source/Python:$(pwd)/../Source/Python
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To run jupyter lab&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cd /dpsim
$ jupyter lab --ip=&amp;quot;0.0.0.0&amp;quot; --allow-root --no-browser
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To install dpsim run&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cd /dpsim/build
$ sudo make install
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;cmake-for-linux&#34;&gt;CMake for Linux&lt;/h2&gt;
&lt;p&gt;The most recent list of requirements can be found in the Dockerfiles.&lt;/p&gt;
&lt;p&gt;Make sure that the required dependencies are installed.
The &lt;a href=&#34;https://git.rwth-aachen.de/acs/public/simulation/dpsim/dpsim/-/blob/master/Packaging/install-fedora-deps.sh&#34;&gt;fedora installation script&lt;/a&gt; in the DPsim repository is a good place to start from.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; There are currently no Debian packages for &lt;code&gt;villas-node&lt;/code&gt; and &lt;code&gt;libcimpp16v29a&lt;/code&gt;.
If you want to use these optional feature, you have to build them manually.&lt;/p&gt;
&lt;p&gt;Install Sundials&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git clone --branch v3.1.1 https://github.com/LLNL/sundials.git
$ mkdir sundials/build
$ pushd sundials/build
$ cmake .. \
    -DBUILD_SHARED_LIBS=ON \
    -DBUILD_STATIC_LIBS=OFF \
    -DEXAMPLES_ENABLE_C=OFF
$ make -j$(nproc) install
$ popd
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The following steps to clone, build and install are the same as for the Docker setup.&lt;/p&gt;
&lt;h2 id=&#34;cmake-for-windows&#34;&gt;CMake for Windows&lt;/h2&gt;
&lt;p&gt;Make sure that the required dependecies are installed:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Visual Studio 2017 with C++ Desktop development package&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://cmake.org/&#34;&gt;CMake&lt;/a&gt; for Windows&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://git-scm.com/download/win&#34;&gt;Git for Windows&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;For Python support, install Python3, for example, Anaconda, and add Python to your PATH.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Clone the project as explained for Docker.&lt;/p&gt;
&lt;p&gt;Open a windows command prompt and navigate into the new DPsim folder.
Generate a Visual Studio project with CMake and use it to build the project&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ mkdir build
$ cd build
$ cmake -G &amp;quot;Visual Studio 15 2017 Win64&amp;quot; ..
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Open Visual Studio and load the Visual Studio project from the build directory within the DPsim folder.&lt;/p&gt;
&lt;p&gt;You can either build the project from within Visual Studio or from the command line by running the following command in the windows command prompt&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cmake --build .
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To install the Python package use Visual Studio and the Release configuration to build the DPsim Python module and then build the INSTALL project.&lt;/p&gt;
&lt;h2 id=&#34;cmake-for-macos&#34;&gt;CMake for macOS&lt;/h2&gt;
&lt;p&gt;Make sure that the required dependecies are installed&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ /usr/bin/ruby -e &amp;quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&amp;quot;
$ brew install gcc9 git cmake graphviz python3 gsl eigen spdlog
$ sudo pip3 install numpy
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Clone the source as explained for the Docker setup.&lt;/p&gt;
&lt;p&gt;Compile&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ mkdir build
$ cmake ..
$ make -j$(sysctl -n hw.ncpu)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To install the generated Python module to your system&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sudo make install
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;python-package-for-pypi&#34;&gt;Python Package for pypi&lt;/h2&gt;
&lt;p&gt;Follow the previous steps to set up the Docker container.&lt;/p&gt;
&lt;p&gt;To build the Python package run&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ python3 setup.py bdist_wheel
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;documentation&#34;&gt;Documentation&lt;/h2&gt;
&lt;h3 id=&#34;python&#34;&gt;Python&lt;/h3&gt;
&lt;p&gt;Install &lt;a href=&#34;https://www.sphinx-doc.org/en/master/&#34;&gt;Sphinx&lt;/a&gt; or use the Docker image.&lt;/p&gt;
&lt;p&gt;Generate the Python documentation by running Sphinx via CMake:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ mkdir -p build &amp;amp;&amp;amp; cd build
$ cmake ..
$ make docs
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The resulting documentation will be generated in &lt;code&gt;Documentation/html/&lt;/code&gt;.&lt;/p&gt;
&lt;h3 id=&#34;c&#34;&gt;C++&lt;/h3&gt;
&lt;p&gt;Install &lt;a href=&#34;http://www.doxygen.nl/&#34;&gt;Doxygen&lt;/a&gt; or use the Docker image.&lt;/p&gt;
&lt;p&gt;Generate the C++ documentation by running Doxygen via CMake:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ mkdir -p build &amp;amp;&amp;amp; cd build
$ cmake ..
$ make docs_cxx
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The resulting documentation will be generated in &lt;code&gt;Documentation/html/Cxx&lt;/code&gt;.&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: Development</title>
      <link>https://dpsim.fein-aachen.org/docs/getting-started/development/</link>
      <pubDate>Thu, 05 Jan 2017 00:00:00 +0000</pubDate>
      
      <guid>https://dpsim.fein-aachen.org/docs/getting-started/development/</guid>
      <description>
        
        
        &lt;h2 id=&#34;environment&#34;&gt;Environment&lt;/h2&gt;
&lt;p&gt;We recommend the following development tools:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Editor: &lt;a href=&#34;https://code.visualstudio.com&#34;&gt;Visual Studio Code&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;Extensions:
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://marketplace.visualstudio.com/items?itemName=ms-vscode.cpptools&#34;&gt;C/C++&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://marketplace.visualstudio.com/items?itemName=ms-python.python&#34;&gt;Python&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://marketplace.visualstudio.com/items?itemName=vector-of-bool.cmake-tools&#34;&gt;CMake Tools&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://marketplace.visualstudio.com/items?itemName=ms-azuretools.vscode-docker&#34;&gt;Docker&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://marketplace.visualstudio.com/items?itemName=EditorConfig.EditorConfig&#34;&gt;EditorConfig for VS Code&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://marketplace.visualstudio.com/items?itemName=ms-vscode-remote.vscode-remote-extensionpack&#34;&gt;Remote Development&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.docker.com&#34;&gt;Docker&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://cmake.org&#34;&gt;CMake&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://git-scm.com&#34;&gt;Git&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;Issues: &lt;a href=&#34;http://git.rwth-aachen.de/acs/public/simulation/dpsim/dpsim/issues&#34;&gt;http://git.rwth-aachen.de/acs/public/simulation/dpsim/dpsim/issues&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Merge Requests: &lt;a href=&#34;http://git.rwth-aachen.de/acs/public/simulation/dpsim/dpsim/merge_requests&#34;&gt;http://git.rwth-aachen.de/acs/public/simulation/dpsim/dpsim/merge_requests&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Continous Integration and Testing: &lt;a href=&#34;http://git.rwth-aachen.de/acs/public/simulation/dpsim/dpsim/pipelines&#34;&gt;http://git.rwth-aachen.de/acs/public/simulation/dpsim/dpsim/pipelines&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Please follow the build instructions to checkout your code and install the basic dependencies and tools.&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: Install</title>
      <link>https://dpsim.fein-aachen.org/docs/getting-started/install/</link>
      <pubDate>Thu, 05 Jan 2017 00:00:00 +0000</pubDate>
      
      <guid>https://dpsim.fein-aachen.org/docs/getting-started/install/</guid>
      <description>
        
        
        &lt;p&gt;DPsim is a Python module / C++ library for complex power system
simulation. As a Python module, the easiest way to get to know DPsim is
via &lt;a href=&#34;https://jupyter-notebook-beginner-guide.readthedocs.io/en/latest/&#34;&gt;Jupyter Notebooks&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;docker&#34;&gt;Docker&lt;/h2&gt;
&lt;p&gt;First, you need to install &lt;a href=&#34;https://docs.docker.com/install/&#34;&gt;Docker&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;To start a Jupyter session, run a DPsim Docker container&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    $ docker run -p 8888:8888 rwthacs/dpsim
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And access the session by opening the following link: http://localhost:8888/lab/tree/Index.ipynb?token=3adaa57df44cea75e60c0169e1b2a98ae8f7de130481b5bc&lt;/p&gt;
&lt;h2 id=&#34;python&#34;&gt;Python&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Currently, the pypi packages are not maintained. Until we have updated the packages, please use the docker installation.&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;prerequisites&#34;&gt;Prerequisites&lt;/h3&gt;
&lt;p&gt;First, you need to make sure that Python is installed and your version is compatible.
An easy way to install Python and all required packages is the &lt;a href=&#34;https://www.anaconda.com/&#34;&gt;Anaconda distribution&lt;/a&gt;.
To get started, install the latest installer for Python 3.x from the &lt;a href=&#34;https://www.anaconda.com/download/&#34;&gt;downloads section&lt;/a&gt;.
Then, run the Anaconda Prompt and create a new conda environment:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ conda create -n dpsim python=3.6
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After creating the environment you need to make sure that it is activated.
The current environment is displayed at the beginning of the command line in brackets.
It should read &lt;em&gt;&amp;quot;(dpsim)&amp;hellip;&amp;quot;&lt;/em&gt;.
In case it is not activated, run:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ activate dpsim
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;pip-package-installation&#34;&gt;Pip Package Installation&lt;/h3&gt;
&lt;p&gt;Then, DPsim can be installed as a Python module:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ pip install dpsim
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;from-source&#34;&gt;From Source&lt;/h2&gt;
&lt;p&gt;To build and install DPsim from the source files, please refer to the build section.&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: Real-Time</title>
      <link>https://dpsim.fein-aachen.org/docs/getting-started/real-time/</link>
      <pubDate>Thu, 05 Jan 2017 00:00:00 +0000</pubDate>
      
      <guid>https://dpsim.fein-aachen.org/docs/getting-started/real-time/</guid>
      <description>
        
        
        &lt;p&gt;This page describes recommended techniques to optimize the host operating system for real-time execution of DPsim.&lt;/p&gt;
&lt;p&gt;In principle, real-time execution is supported on all platforms.
However, we recommend to use an optimized Linux installation.&lt;/p&gt;
&lt;h2 id=&#34;operating-system-and-kernel&#34;&gt;Operating System and Kernel&lt;/h2&gt;
&lt;p&gt;For minimum latency several kernel and driver settings can be optimized.&lt;/p&gt;
&lt;p&gt;To get started, we recommend the &lt;a href=&#34;https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_MRG/2/html/Realtime_Tuning_Guide/index.html&#34;&gt;Redhat Real-time Tuning Guide&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;A &lt;a href=&#34;https://rt.wiki.kernel.org/index.php/Main_Page&#34;&gt;PREEMPT_RT patched Linux&lt;/a&gt; kernel is recommended.
Precompiled kernels for Fedora can be found here: &lt;a href=&#34;http://ccrma.stanford.edu/planetccrma/software/&#34;&gt;http://ccrma.stanford.edu/planetccrma/software/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Use the &lt;em&gt;tuned&lt;/em&gt; tool for improving general real-time performance.
Please adjust the setting &lt;code&gt;isolated_cpucores&lt;/code&gt; according to your hardware and enable the &lt;code&gt;realtime&lt;/code&gt; profile as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  $ dnf install tuned-profiles-realtime
  $ echo &amp;quot;realtime&amp;quot; &amp;gt; /etc/tuned/active_profile
  $ echo &amp;quot;isolated_cpucores=6-7&amp;quot; &amp;gt;&amp;gt; /etc/tuned/realtime-variables.conf
  $ systemctl enable tuned &amp;amp;&amp;amp; systemctl start tuned
  $ systemctl reboot
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;running-a-real-time-simulation&#34;&gt;Running a real-time simulation&lt;/h2&gt;
&lt;p&gt;As a reference, real-time simulation examples are provided in the Examples/Cxx folder of the DPsim repository.&lt;/p&gt;
&lt;p&gt;In order to run a real-time simulation, the simulation process must be started in a special way in order to change the execution priority, scheduler and CPU affinity.
For this purpose the &lt;code&gt;chrt&lt;/code&gt; and &lt;code&gt;taskset&lt;/code&gt; commands are used.
In the following example, we pin the execution of the simulation to CPU cores 6-7 which have been reserved previously by the tuned real-time profile (see above).&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  $ taskset --all-tasks --cpu-list 6-7 \
  $ chrt --fifo 99 \
  $ Examples/Cxx/RT_DP_CS_R_1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;More details:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://man7.org/linux/man-pages/man1/chrt.1.html&#34;&gt;chrt man-page&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://man7.org/linux/man-pages/man1/taskset.1.html&#34;&gt;taskset man-page&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;recommended-hardware&#34;&gt;Recommended Hardware&lt;/h2&gt;
&lt;p&gt;Some proposals for the selection of appropriate server hardware:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Server-grade CPU, e.g. Intel Xeon. A multi-core system enables true parallel execution of several decoupled systems&lt;/li&gt;
&lt;li&gt;Server-grade network cards, e.g. Intel PRO/1000. These allow offloading of UDP checksumming to the hardware&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
  </channel>
</rss>
